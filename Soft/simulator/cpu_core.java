package tk.zmj1316.CPU;/** * Created by Key on 2015/9/20. * (C) Key Zhang 2015 */public class cpu_core {    protected Memory mem;    protected byte stage;    protected int signal;    protected int []Regfile;    protected int PC;    protected int JUMP;    protected byte OP,RS,RT,RD,shamt,func;    protected int imme;    protected byte Dst;    protected int RA,RB,ALUres,A,B;    protected int IR;    protected int ctrl(byte OP) {        switch (OP) {            case 0:return 0b1100010100000;            case 2:return 0b0011000000001;            case 3:return 0b0011100100101;            case 4:            case 5:return 0b0011000000010;            case 8:return 0b0110000100000;            case 0x23:return 0b0110001110000;            case 0x2B:return 0b0110000001000;            default: return 0b0110000100000;        }    }    public cpu_core() {        PC = 0;        IR = 0;        stage = 0;        Regfile = new int[32];    }    public void run(){        while(true){            switch (stage){                case 0:                    IR = mem.getWord(PC);                    PC += 4;                    OP = (byte) (IR >> 26);                    RS = (byte) ((IR >> 21 )& 0xFF);                    RT = (byte) ((IR >> 16 )& 0xFF);                    RD = (byte) ((IR >> 11 )& 0xFF);                    JUMP = IR & 0x03FFFFFF;                    shamt = (byte) ((IR >> 6 )& 0x1F);                    func = (byte) (IR & 0x3F);                    imme = (IR & 0x8000) == 0x8000 ? (IR | 0xFFFF0000) : (IR & 0x0000FFFF);                    signal = ctrl(OP);                    break;                case 1:                    RA = Regfile[RS];                    RB = Regfile[RT];                    switch ((signal >> 7) & 3) {                        case 0:                            Dst = RT;                            break;                        case 1:                            Dst = RD;                            break;                        case 2:                            Dst = 31;                            break;                    }                    break;                case 2:                    A = ((signal >> 11) & 1) == 1 ? RA : PC;                    switch ((signal >> 9) & 3) {                        case 0:                            B = RB;                            break;                        case 1:                            B = 4;                            break;                        case 2:                            B = imme;                            break;                        case 3:                            B = (imme << 2);                            break;                    }                    if (((signal >> 12) & 1) == 1) {                        switch (func) {                            case 0x20:case 0x21:                                ALUres = A + B;                                break;                            case 0x22:case 0x23:                                ALUres = A - B;                                break;                            case 0x24:                                ALUres = A & B;                                break;                            case 0x25:                                ALUres = A | B;                                break;                            case 0x26:                                ALUres = A ^ B;                                break;                            case 0x27:                                ALUres = ~ (A | B);                                break;                            case 0x2A:                                ALUres = A < B ? 1 : 0;//signed                                break;                            case 0x2B:                                ALUres = (long) A < (long) B ? 1 : 0;                                break;                            case 0:                                ALUres = B << shamt;                                break;                        }                    }                    else {                        ALUres = A + B;                        switch (OP) {                            case 0xc:                                ALUres = A & B;                                break;                            case 0xd:                                ALUres = A | B;                                break;                            case 0xe:                                ALUres = A ^ B;                                break;                            case 0xf:                                ALUres = (B << 16) & 0xFFFF0000;                                break;                        }                    }            }        }    }}